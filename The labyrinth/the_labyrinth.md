# The Labyrinth
Решал эту задачу после [Moves in maze](../Moves%20in%20maze/moves_in_maze.md).

Задача довольно интересна, так как требует разделения на подзадачи, что очень приближено к реальности.

## Решение
Данную задачу можно разбить на несколько подзадач:
1. Обход всех ячеек лабиринта для его сканирования
2. После обхода всех ячеек кратчайшим путем добраться до ячейки с консолью
3. От ячейки с консолью кратчайшим путем добраться до выхода

Первый пункт решается с помощью [BFS](https://www.redblobgames.com/pathfinding/a-star/introduction.html#breadth-first-search), пункты 2 и 3 требую взвешенного пути точка-точка, следовательно отлично подойдет [A*](https://www.redblobgames.com/pathfinding/a-star/introduction.html#astar) алгоритм.

Для решения данной задачи очень полезным оказался сайт [redblobgames.com](https://redblobgames.com), автор которого очень граммотно (по моему мнению) и иллюстративно объясняет работу самых распространненых алгоритмов обхода графа. 

Пояснения по алгоритму даны непосредственно в [коде](the_labyrinth.cpp).

*Обход абсолютно всех ячеек работает в данных условиях, но не подойдет при большем размере лабиринта или меньшем количестве топлива.*

## Сложности
Основной сложностью для меня было изначально правильно разбить задачу на подзадачи, поэтому первые попытки решения состояли из одного A* алгоритма.

Перечитав условия задачи и простроив последовательность действий, довольно быстро пришел к выводу о том, что нужно два алгоритма обхода.

Так же не сразу догадался о том, как одновременно игнорировать уже посещенные ячейки, но иметь возможность обратно возвращаться из тупиков.